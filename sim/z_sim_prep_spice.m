% This takes NET list of model made in e.g. LTspice and it preprocesses it:
% 1) it will expand certain library models directly to NET list. This is 
%    is done mainly for cables, so the stray couplings e.g. from cable-cable
%    can be procedurally generated to the NET list
% 2) It expands templates, which are used in the Spice model for repetitively
%    placed objects like cables, ADCs, etc.
% 3) Places libraries directly to NET list so it is faster to read for multicore
%    processing.
% 4) Generates additional NET list commands representing stray couplings between
%    e.g. cables.
% 5) Saves the modified NET list to temp file CIR
% If CIR already exists, it will not repeat the process above, but rather reaload
% it and also reloads additional information stored in it.
% 
% usage: 
%   [md,stray,templatez,sense] = z_sim_prep_spice(md,stray)
%
% parameters:
%   md - Spice session/model structure:
%     md.spice_fld - spice binary folder
%     md.mod_fld - spice models and libs folder
%     md.name - model name without file extension
%     md.spice - ngspice binary name;
%     md.spice_temp - ngspice temp folder (e.g. the same as spice_fld)
%     md.ngspice.useraw - nonzero to transfer data to Spice via files
%                         zero to use pipe mode with Spice in background process
%     md.force_reload - always reload and process NET list
%   stray - cell array of structures of stray couplings to be generated between 
%           the model objects (one cell per group to be generated):
%     stray.names - list of model element names (usually cables or plain lugs) between 
%                   which the couplings should be generated     
%     stray.names2 - secondary list to 'stray.names'. If empty, the strays are 
%                    generated between each possible pair in 'stray.names'.
%                    If non-empty, it will generate each combination
%                    'stray.names' to 'stray.names2'.
%     stray.M, stray.C - vectors of stray values matching the possible combinations
%                        counts above  
%
% returns:
%   md - modified 'md' input, do not loose
%   stray - input 'stray' accompanied by list of paticular paremeters generated to the
%           NET list, i.e. stray.C/M values are to be assined to parameter names:
%     stray.M_names - list of mutual couplings       
%     stray.C_names - list of capacitive couplings
%         - the asignement takes place in z_brg_sim()
%   templatez - loaded template definitions to be used in z_brg_sim() by 
%           z_sim_template_assign() function
%   sense - current balance sensing spots (not used)
%           it was intended to evaluate current inbalance in cable, but not finished
%
% This is part of open-z-bridge project: https://github.com/smaslan/open-z-bridge
% (c) 2021, Stanislav Maslan, smaslan@cmi.cz/s.maslan@seznam.cz
% The script is distributed under MIT license, https://opensource.org/licenses/MIT.                
%  
function [md,stray,templatez,sense] = z_sim_prep_spice(md,stray)
 
    % source file from LTspice generated by "view spice NET"
    %  note: disappears when LTspice closed!
    net_file = [md.mod_fld filesep md.name '.net'];
    
    % local copy of NET without rubbish
    cir_file = [md.mod_fld filesep md.name '.cir'];
     
    % make working copy of NET list:
    if ~exist(cir_file,'file') || (md.force_reload && exist(net_file,'file'))
        
        % load NET file:
        fid = fopen(net_file,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        net = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        % remove rubbish:
        net = strrep(net,'.backanno','');
        
        % expand parameter templates in *.NET
        [net,templatez] = spice_expand_templates(net);              
                 
        % expand given libs to main *.NET
        [net,spec] = spice_expand_libs(net_file,net,{'COAXCAB','COAXCABGL','GNDLUG','TWAXSH','TWCABSH'});
                
        % filter out sense elements only
        sense = spec(~~(cellfun(@getfield,spec,{'is_sense'})));                  
        
        % expand libs data to *.NET file
        [net] = spice_paste_libs(net_file, net);            
        
        % generate stray elements (mutual couplings and capacitances)
        [net,stray] = z_sim_generate_model_strays(net, spec, stray);
        
        % store net to model structure
        md.net = net;

        % store to local copy:
        fw = fopen(cir_file,'w');
        fputs(fw,net);
        fclose(fw);
    
    else
        % parse some datas from already processed NET
        
        % load NET file:
        fid = fopen(cir_file,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        net = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        
        % expand parameter templates in *.NET
        [net,templatez] = spice_expand_templates(net, 1);
        
        % reload stray data from CIR file
        [net,stray] = z_sim_generate_model_strays(net, [], stray);            
        
    end

end

% searches directive: .lib LIB_PATH LIB_NAME
% and replaces it with LIB content
function [net] = spice_paste_libs(net_path, net)

    % this file root folder   
    net_root = fileparts(net_path);
    
    % --- for each found .lib directive
    [a,b,c,d,e] = regexp(net,'\.lib\s+([^\s]+)\s+([^\s]+)\s*');
    for lib = 1:numel(d)
        
        % try to load LIB file content
        lib_file = fullfile(net_root, e{lib}{1});
        fid = fopen(lib_file,'r');
        if fid == -1
            error(sprintf('Loading LIB file ''%s'' failed!',lib_file));
        end
        lib_data = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        
        % extract LIB file content
        [aa,bb,cc,dd,ee] = regexp(lib_data,'\.LIB\s+[^\s]+\s*(.*?)\.ENDL');
                              
        % replace .lib directive by LIB content
        lib_data = sprintf('\n\n*** CONTENT OF LIB FILE: %s ***\n%s\n*** END OF CONTENT OF LIB FILE: %s ***\n\n',lib_file,ee{1}{1},lib_file);
        net = strrep(net, d{lib}, lib_data);
        %net = [net sprintf('\n') ];

        % expand lib path to absolute
        %net = [net(1:c{lib}(1,1)-1) '"' lib_file '"' net(c{lib}(1,2)+1:end)];               
                            
    endfor

endfunction


% searches for X copoments with tag <template=my_template_name> as a parameter and then replaces the tag
% by template that must be present in NET list in format:
% * <my_template_name>par_name=par_value% another_par_name=another_par_value</my_template_name>
% where '%' will be replaced by component_id: Xcomponent_id node1 node2 ...
%
% Example NET input:
% Xmy_coax n001 n002 n003 n004 COAX <template=my_template>
% * <my_template>Rs={Rs_%} Ls={Rs_%}\n Cp={Cp_%} Rp={Rp_%}</my_template>
% Example NET output:
% Xmy_coax n001 n002 n003 n004 COAX Rs={Rs_my_coax} Ls={Ls_my_coax} Cp={Cp_my_coax} Rp={Rp_my_coax}
%
% Note: intention of this is to prevent writing a ton of parameters to each component, e.g. many coaxial cables.
function [net,templates] = spice_expand_templates(net, load_only=0)
    
    % used templates
    templates = {};
    
    if load_only
        % --- reading already processed data mode ---
        % note: we just read tags inserted previously to build templates list
        
        % for each tag:
        [a,b,c,d,e] = regexp(net,'\*\s* <component=([^>]+)>([^<]+)</component>');
        for t = 1:numel(e)
            % parse parameters
            
            clear temp;
            
            % extract component name 
            temp.component = e{t}{1};
            
            % build pairs model name - global parameters name without {} 
            [pa,pb,pc,pd,pe] = regexp(e{t}{2},'\s*([^=]+)=([^\s\n]+)');
            for p = 1:numel(pe)
                temp.parameter_ref{p} = pe{p}{1};
                temp.parameter_name{p} = pe{p}{2};
            endfor
            
            % make one template item
            templates{end+1} = temp;
    
        endfor         
    
    else
        % --- processing mode ---
    
        % search for required templates
        [na,nb,nc,nd,ne] = regexp(net,'X([^\s\n]+)[^<\n]+(<template=[^>\n]+>)\s*(<param=([^>\n]+)>)?');
        
        % get unique template names
        names = {};
        for k = 1:numel(ne)
            [a,b,c,d,e] = regexp(ne{k}{2},'[^=]+=([^>]+)');
            names{end+1} = e{1}{1};
            ne{k}{2} = e{1}{1};    
        endfor
        names = unique(names);
        
        % search templates
        tmpl = {};
        for k = 1:numel(names)
                    
            [a,b,c,d,e] = regexp(net,sprintf('.*\\*\\s<%s>(.*)</%s>',names{k},names{k}));
            if isempty(e)
                error(sprintf('Expanding Spice templates: Cannot find template ''%s'' definition!',names{k}));
            endif
            
            % get rid of line breaks
            tdata = strrep(e{1}{1},'\n',' ');
            
            % split parameters
            [a,b,c,d,e] = regexp(tdata,'\s*([^=]+)=([^\s\n\r]+)');
            
            % store template record
            tmpl{k}.name = names{k};
            tmpl{k}.data = e;        
            
        endfor  
            
        % --- for each template: expand
        for k = numel(ne):-1:1
        
            % template name 
            component_template = ne{k}{2};
            % component id
            component_id = ne{k}{1};
            % parameter to replace (optional)
            if numel(ne{k}) == 4
                % is explicitly defined
                parameter = ne{k}{4};
            else
                % implicit definition - use component id            
                parameter = component_id;
            endif
            
            
            % get required template data
            tid = find(strcmp(names,component_template),1);
            if isempty(tid)
                error(sprintf('Expanding Spice templates: Cannot find template ''%s'' definition!',componenet_tid));
            endif                
            tdata = tmpl{tid};
            
            % build parameters using template
            par = '';
            par_list = '';
            param_refs = {};
            param_names = {};
            for p = 1:numel(tdata.data)        
                
                local_par = tdata.data{p}{1};
                global_par = tdata.data{p}{2};
                
                % expand parameter(s) in the template
                global_par = strrep(global_par, '%', parameter);
                
                % build parameters string
                par = [par local_par '=' global_par ' '];
                
                % build pairs model name - global parameters name without {} 
                param_refs{p} = local_par;
                [a,b,c,d,e] = regexp(global_par,'\{([^\}]+)\}');
                if ~isempty(e)
                    global_par = e{1}{1};
                endif
                param_names{p} = global_par;
                
                % build parameters list without {}
                par_list = [par_list local_par '=' global_par ' '];                                                
                
            endfor
            
            % add record to used templates list            
            %templates{k}.name = component_template;
            templates{k}.component = component_id;            
            templates{k}.parameter_ref = param_refs;
            templates{k}.parameter_name = param_names;
            
            if numel(ne{k}) == 4
                % remove explicit parameter tag <param=?>
                net = [net(1:nc{k}(3,1)-1) net(nc{k}(3,2)+1:end)];
            endif
            
            % replace template tag <template=template_name> by generated parameters
            net = [net(1:nc{k}(2,1)-1) par net(nc{k}(2,2)+1:end)];
                 
            % insert processed parameters for future info
            inf = ['* <component=' component_id '>' par_list '</component>' sprintf("\n")];
            eol = find(net(1:nc{k}(1,1))=="\n",1,'last');        
            net = [net(1:eol) inf net(eol+1:end)];
                        
        endfor
    
    endif
    
endfunction

% truncates string to first line break
function [str] = str_get_line(str)
    cr = strfind(str,char(13));
    lf = strfind(str,char(10));
    [v,id] = min([cr lf]);
    if ~isempty(v)
        str = str(1:v-1);
    endif        
endfunction





% expand given LIB models to NET
function [net,items] = spice_expand_libs(net_path,net,list)
    
    % list of special data for particular lib models
    items = {};
    
    % this file root folder   
    net_root = fileparts(net_path);
    
    % look for lib files
    lid = strfind(net,'.lib');
    if isempty(lid)
        error('Expanding Spice libs: no lib file found!');
    endif
    
    % get lib files paths
    for k = 1:numel(lid)
        [a,b,c,d,e] = regexp(str_get_line(net(lid(k):end)),'.lib\s+([^\s]+)\s+([^\s]+)');
        libz(k).path = [net_root filesep e{1}{1}];
        libz(k).name = e{1}{2};
    endfor
    
    % process libz
    for k = 1:numel(libz)
    
        % read lib file
        fid = fopen(libz(k).path,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        lib = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        
        % all replacements done?
        if isempty(list)
            break;
        endif
    
        for m = 1:numel(list)         
            % take one subcircuit to expand from the list
            subckt = list{m};
            
            sid = strfind(lib,'.SUBCKT');
            for s = 1:numel(sid)
                [a,len,c,d,e] = regexp(str_get_line(lib(sid(s):end)),'.SUBCKT\s+([^\s]+)\s+([^\n]+)');                
                if strcmpi(e{1}{1},subckt)
                    % -- found the right .SUBCKT name
                    
                    % .SUBCKT name [opts]
                    opts = e{1}{2};                    
                                        
                    % look for end of .ENDS name
                    [a,b,c,d,e] = regexp(lib(sid(s):end),['.ENDS\s+' subckt '\>']);
                    if isempty(a)
                        error(sprintf('Expanding Spice libs: SUBCKT ''%s'' has no matching .ENDS?',subckt));
                    endif         
                    
                    % subcircuit data
                    sdata = lib(sid(s)+len+1:sid(s)+a-3);                              
                    
                    % extract parameters (.SUBCKT name ... params)
                    [a,b,c,d,e] = regexp(opts,'([^\s=]+)=[^\s]+');
                    params = {};
                    for p = 1:numel(e)
                        params{p} = e{p}{1};
                    endfor
                    P = numel(params);
                    
                    % extract node names (.SUBCKT name nodes ...)
                    [a,b,c,d,e] = regexp(opts(1:min(a)-1),'([^\s]+)');
                    nodes = {};
                    for p = 1:numel(e)
                        nodes{p} = e{p}{1};
                    endfor
                    N = numel(nodes);                   
                    
                    % build search pattern for SUBCKT in NET
                    regs = 'X([^\s]+)\s+';
                    regs = [regs repmat('([^\s]+)\s+',[1 N])];
                    regs = [regs subckt '\s+'];
                    regs = [regs repmat('([^=]+)=([^\s]+)\s+',[1 P])];
                    
                    % search all occurences in NET
                    [a,b,c,ncmd,sckt_net] = regexp(net,regs);

                    % -- for each occurence - replace with lib SUBCKT
                    subst = {}; 
                    for n = 1:numel(sckt_net)
                    
                        % NET nodes to be assigned to SUBCKT
                        nodes_rep = sckt_net{n}(2:N+1);
                        
                        %params
                        %sckt_net{n}(N+2:2:end)
                        
                        % NET parameters to be assigned to SUBCKT
                        params_rep = {};
                        for p = 1:P
                            pid = find(strcmp(sckt_net{n}(N+2:2:end),params(p)));
                            if isempty(pid)
                                error(sprintf('Expanding Spice libs: SUBCKT ''%s'' has undefined parameter ''%s'' in NET? NET command: \n',subckt,params{p},ncmd{n}));    
                            endif
                            params_rep{p} = sckt_net{n}{N + 2*pid + 1};
                        endfor
                        
                        % sort params from longest to shortest (needed for simpler strrep() in further code)
                        [params,params_rep] = sort_params(params,params_rep);
                        
                        % -- parse SUBCKT line by line
                        ptemp.params     = params;
                        ptemp.params_rep = params_rep;
                        %item  = struct('name','','C_name',{{}},'L_name',{{}},'L_val',{{}},'is_sense',[]);
                        item  = struct('name','','C_name',{{}},'L_name',{{}},'L_val',{{}},'is_sense',0);
                        %sense = struct('name','','list',{{}},'Rs',[]);
                        temp = sdata;                        
                        while true
                            [tok,temp] = strtok(temp, "\n");
                            if isempty(tok)
                                break;
                            endif
                            
                            % parse/replace line
                            [cmd, spec, params, params_rep] = spice_expand_command(tok, n, subckt, nodes, nodes_rep, params, params_rep);
                            
                            if ~isempty(spec)
                                % some coupling tag found - process
                                item.name = sckt_net{n}{1};
                                if spec.is_sense
                                    % current sensing element                                                                        
                                    item.is_sense = 1;
                                    item.R_name{end+1,1} = spec.nodes;
                                    item.Rs = spec.Rs;                                    
                                elseif spec.is_node
                                    % node - for capacitive coupling
                                    item.C_name{end+1} = spec.node;
                                else
                                    % component - inductive coupling
                                    item.L_name{end+1} = spec.id;
                                    item.L_val{end+1}  = spec.value;
                                endif                                                                
                            endif
                            
                            % expand command to NET
                            if numel(subst) < n
                                subst{n} = '';    
                            endif
                            subst{n} = [subst{n} cmd];                            
                        endwhile                        
                        params = ptemp.params;
                        params_rep = ptemp.params_rep;
                        
                        % add special data to list
                        if ~isempty(item)
                            % some tag found - process                            
                            items{end+1,1} = item; 
                        endif
                    
                    endfor
                    
                    % replace SUBCKTs in NET by LIB SUBCKTs
                    for n = 1:numel(sckt_net)
                        net = strrep(net,ncmd{n},subst{n});
                    endfor
                    
                endif
                    
            endfor            
               
        endfor
        
    endfor

endfunction

% this is helper function that keeps parameter strings sorted by size from longest so simple strrep() can be used to replace them
function [params,params_rep] = sort_params(params,params_rep)
    lenz = cellfun(@length,params,'UniformOutput',true);
    [v,id] = sort(lenz,'descend');
    params = params(id);
    params_rep = params_rep(id);    
endfunction

% replace command line of LIB model by NET nodes and parameters
function [cmd,item, params,params_rep] = spice_expand_command(cmd, sck_id, subckt, nodes, nodes_rep, params, params_rep)

    % no special item to return yet
    item = [];
    
    % unique subcircuit tag 
    sck_id = sprintf('%s%02d',subckt,sck_id);
    
    % check if is .param <definitions>
    [a,b,c,d,e] = regexp(cmd,'\s*.param\s+([^\n\$]+)');
    if ~isempty(a)
        % --- .param <definition(s)>
        
        cmd = '.param ';
        
        % globalize local parameters so it can be pasted to global NET 
        cpar = e{1}{1};
        while true
            [par,cpar] = strtok(cpar, " \t");
            if isempty(par)
                break;
            endif
            [a,b,c,d,e] = regexp(par,'\s*([^=]+)=([^\n\r]+)');
            
            % local name of parameter
            params{end+1} = e{1}{1};
            % globalized name of local parameter
            param_glob = [e{1}{1} '_' sck_id];
            params_rep{end+1}  = ['{' param_glob '}'];
            
            % replace local .SUBCKT params by globals
            % note: two pass replace because in local and global names may be identical (at least partly)
            rep_keys = {}; 
            rep_reps = {};
            value = e{1}{2};                        
            for p = 1:numel(params) % first pass - replace to temp keys 
                rep = params_rep{p};
                [a,b,c,d,e] = regexp(rep,'\{([^}]+)\}');
                if ~isempty(a)
                    rep = e{1}{1};
                endif
                rep_keys{p} = ['%' int2str(rand*1e16) '%']; % temp key
                rep_reps{p} = rep; % final replacement for second pass
                value = strrep(value,params{p},rep_keys{p});
            endfor
            for p = 1:numel(params) % second pass - final replace
                value = strrep(value,rep_keys{p},rep_reps{p});
            endfor
            
            % build new .param command with globalized parameters 
            cmd = [cmd param_glob '=' value ' '];
            
            % sort parameters
            [params,params_rep] = sort_params(params,params_rep);
                        
        endwhile        
        cmd = [cmd sprintf("\n")];
        
        % we are done with this line
        return                
    endif
    
    % try parse command
    [a,b,c,d,e] = regexp(cmd,'^[^*\s]*([A-Z])([^\s]+)\s+([^\n]+)');
    
    if isempty(a)
        % no command, but it may be something else
        cmd = '';
    else
        % --- some command detected
        
        % command code
        ctype = e{1}{1};
        
        % component index
        cid = e{1}{2};
        
        % component parameters
        cpar = e{1}{3};
                
        % identify command type so we know node counts
        switch ctype
            case {'R', 'L', 'C', 'K'}
                cN = 2;
                cP = 1;
            case 'E'
                cN = 4;
                cP = 1;
            otherwise
                error(sprintf('Expanding Spice libs: command ''%s'' in SUBCKT ''%s'' not supported yet.',ctype,subckt));
        endswitch
        
        % element name/code
        element_name = [ctype cid sck_id];
        
        % build command string 
        cmd = [element_name ' '];
               
        % parse and replace nodes and parameters
        is_node = 1;
        node = cN;
        glob_nodes = {};
        while true
            [par,cpar] = strtok(cpar, " \t");
            if isempty(par)
                break;
            endif
            
            if is_node == 1
                % parsing nodes
                
                nid = find(strcmp(nodes,par));
                if isempty(nid)
                    % node is local - just make unique name
                    node_name = [par sck_id];
                else
                    % node is external - replace by external node name
                    node_name = nodes_rep{nid};
                endif
                
                % store globalized node name
                glob_nodes{end+1} = node_name;
                
                % add new node to command
                cmd = [cmd node_name ' '];
                
                cN--;
                if ~cN
                    is_node = 0; % nodes done, goto parameters
                endif
            elseif is_node == 0
                % parsing parameters
                
                [a,b,c,d,e] = regexp(par,'\{(.+)\}');
                if isempty(a)
                    % parameter is local - let it as is
                    par_value = str_get_line(par);                   
                else
                    % parameter is external - replace by external
                    pid = find(strcmp(params,e{1}{1}));
                    if isempty(pid)
                        error(sprintf('Expanding Spice libs: command ''%s'' in SUBCKT ''%s'' contains reference to unknown parameter ''%s''.',ctype,subckt,par));
                    endif
                    par_value = params_rep{pid};
                endif

                % add new node to command
                cmd = [cmd par_value ' '];
                
                cP--;
                if ~cP
                    is_node = -1; % parameters done, goto comment
                endif
            endif
            
            % parsing comment (if exist)
            if is_node < 0
                [a,b,c,d,e] = regexp(cpar,'\s*\$\s+<([^>]+)>');
                if ~isempty(a)
                    
                    % item is current sensing marker
                    if strcmpi(e{1}{1},'sense');
                        % -- is sensing resistor
                        item.is_sense = 1;
                    
                        % store list of sensing nodes (sides of resistor)
                        item.nodes = glob_nodes;                        
                        % store sensing resistor value (converted to number)
                        item.Rs = str2num(par_value);
                    
                    else
                        % -- is stray injection point
                        item.is_sense = 0;
                    
                        % found special tag <tag> in comment - this marks injection point for parasitic coupling
                        item.tag = e{1}{1};
                        
                        % related node
                        [a,b,c,d,e] = regexp(item.tag,'([^:]+):(.+)');
                        if ~isempty(a)
                            % explicitly defined <C:node_id> where 'node_id' is one-based index 
                            item.tag = e{1}{1}; 
                            item.node = glob_nodes{str2num(e{1}{2})};
                        else
                            % implicitly defined (first node)
                            item.node = glob_nodes{1};
                        endif                     
                        
                        % item type (node or inductor)
                        item.is_node = strcmpi(item.tag,'C');
                        
                        % command code (like inductor Lxxx or whatever)
                        item.id = element_name;
                        
                        % element value
                        [a,b,c,d,e] = regexp(par_value,'\{(.+)\}');
                        if ~isempty(a)
                            par_value = e{1}{1}; % get rid of {}
                        endif                     
                        item.value = par_value;
                        
                    endif
                    
                endif
                break;
            endif                                
            
        endwhile
        
        % append end of line
        cmd = sprintf('%s\n',cmd);       
    
    endif    

endfunction