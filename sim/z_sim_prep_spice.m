function [md,stray] = z_sim_prep_spice(md,stray)
  
    % source file from LTspice generated by "view spice NET"
    %  note: disappears when LTspice closed!
    net_file = [md.mod_fld filesep md.name '.net'];
    
    % local copy of NET without rubbish
    cir_file = [md.mod_fld filesep md.name '.cir'];
     
    % make working copy of NET list:
    if ~exist(cir_file,'file') || (md.force_reload && exist(net_file,'file'))
        
        % load NET file:
        fid = fopen(net_file,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        net = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        % remove rubbish:
        net = strrep(net,'.backanno','');
        
        % expand given libs to main *.NET
        [net,spec] = spice_expand_libs(net_file,net,{'COAXCAB','GNDLUG','TWAXSH'});
        
        % generate stray elements (mutual couplings and capacitances)
        [net,stray] = z_sim_generate_model_strays(net, spec, stray);

        % store to local copy:
        fw = fopen(cir_file,'w');
        fputs(fw,net);
        fclose(fw);
    
    else
        % parse some datas from already processed NET
        
        % load NET file:
        fid = fopen(cir_file,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        net = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        
        % reload stray data from CIR file
        [net,stray] = z_sim_generate_model_strays(net, [], stray);            
        
    end

end

% truncates string to first line break
function [str] = str_get_line(str)
    cr = strfind(str,char(13));
    lf = strfind(str,char(10));
    [v,id] = min([cr lf]);
    if ~isempty(v)
        str = str(1:v-1);
    endif        
endfunction


% expand given LIB models to NET
function [net,items] = spice_expand_libs(net_path,net,list)
    
    % list of special data for particular lib models
    items = {};
    
    % this file root folder   
    net_root = fileparts(net_path);
    
    % look for lib files
    lid = strfind(net,'.lib');
    if isempty(lid)
        error('Expanding Spice libs: no lib file found!');
    endif
    
    % get lib files paths
    for k = 1:numel(lid)
        [a,b,c,d,e] = regexp(str_get_line(net(lid(k):end)),'.lib\s+([^\s]+)\s+([^\s]+)');
        libz(k).path = [net_root filesep e{1}{1}];
        libz(k).name = e{1}{2};
    endfor
    
    % process libz
    for k = 1:numel(libz)
    
        % read lib file
        fid = fopen(libz(k).path,'r');
        if fid == -1
            error('Loading NET list failed!');
        end
        lib = fread(fid, [1,inf], 'uint8=>char');
        fclose(fid);
        
        % all replacements done?
        if isempty(list)
            break;
        endif
    
        for m = 1:numel(list)         
            % take one subcircuit to expand from the list
            subckt = list{m};
            
            sid = strfind(lib,'.SUBCKT');
            for s = 1:numel(sid)
                [a,len,c,d,e] = regexp(str_get_line(lib(sid(s):end)),'.SUBCKT\s+([^\s]+)\s+([^\n]+)');                
                if strcmpi(e{1}{1},subckt)
                    % -- found the right .SUBCKT name
                    
                    % .SUBCKT name [opts]
                    opts = e{1}{2};                    
                                        
                    % look for end of .ENDS name
                    [a,b,c,d,e] = regexp(lib(sid(s):end),['.ENDS\s+' subckt '\>']);
                    if isempty(a)
                        error(sprintf('Expanding Spice libs: SUBCKT ''%s'' has no matching .ENDS?',subckt));
                    endif         
                    
                    % subcircuit data
                    sdata = lib(sid(s)+len+1:sid(s)+a-3);                              
                    
                    % extract parameters (.SUBCKT name ... params)
                    [a,b,c,d,e] = regexp(opts,'([^\s=]+)=[^\s]+');
                    params = {};
                    for p = 1:numel(e)
                        params{p} = e{p}{1};
                    endfor
                    P = numel(params);
                    
                    % extract node names (.SUBCKT name nodes ...)
                    [a,b,c,d,e] = regexp(opts(1:min(a)-1),'([^\s]+)');
                    nodes = {};
                    for p = 1:numel(e)
                        nodes{p} = e{p}{1};
                    endfor
                    N = numel(nodes);                   
                    
                    % build search pattern for SUBCKT in NET
                    regs = 'X([^\s]+)\s+';
                    regs = [regs repmat('([^\s]+)\s+',[1 N])];
                    regs = [regs subckt '\s+'];
                    regs = [regs repmat('([^=]+)=([^\s]+)\s+',[1 P])];
                    
                    % search all occurences in NET
                    [a,b,c,ncmd,sckt_net] = regexp(net,regs);

                    % -- for each occurence - replace with lib SUBCKT
                    subst = {}; 
                    for n = 1:numel(sckt_net)
                    
                        % NET nodes to be assigned to SUBCKT
                        nodes_rep = sckt_net{n}(2:N+1);
                        
                        % NET parameters to be assigned to SUBCKT
                        params_rep = {};
                        for p = 1:P
                            pid = find(strcmp(sckt_net{n}(N+2:2:end),params(p)));
                            if isempty(pid)
                                error(sprintf('Expanding Spice libs: SUBCKT ''%s'' has undefined parameter ''%s'' in NET? NET command: \n',subckt,params(p),ncmd{n}));    
                            endif
                            params_rep{p} = sckt_net{n}{N + 2*pid + 1};
                        endfor
                        
                        % sort params from longest to shortest (needed for simpler strrep() in further code)
                        [params,params_rep] = sort_params(params,params_rep);
                        
                        % -- parse SUBCKT line by line
                        item = struct('name','','C_name',{{}},'L_name',{{}},'L_val',{{}});
                        temp = sdata;                        
                        while true
                            [tok,temp] = strtok(temp, "\n");
                            if isempty(tok)
                                break;
                            endif
                            
                            % parse/replace line
                            [cmd, spec, params, params_rep] = spice_expand_command(tok, n, subckt, nodes, nodes_rep, params, params_rep);
                            
                            if ~isempty(spec)
                                % some coupling tag found - process
                                item.name = sckt_net{n}{1};
                                if spec.is_node
                                    % node - for capacitive coupling
                                    item.C_name{end+1} = spec.node;
                                else
                                    % component - inductive coupling
                                    item.L_name{end+1} = spec.id;
                                    item.L_val{end+1}  = spec.value;
                                endif                                                                
                            endif
                            
                            % expand command to NET
                            if numel(subst) < n
                                subst{n} = '';    
                            endif
                            subst{n} = [subst{n} cmd];                            
                        endwhile
                        
                        % add special data to list
                        if ~isempty(item)
                            % some tag found - process                            
                            items{end+1,1} = item; 
                        endif
                    
                    endfor
                    
                    % replace SUBCKTs in NET by LIB SUBCKTs
                    for n = 1:numel(sckt_net)
                        net = strrep(net,ncmd{n},subst{n});
                    endfor
                    
                endif
                    
            endfor            
               
        endfor
        
    endfor

endfunction

% this is helper function that keeps parameter strings sorted by size from longest so simple strrep() can be used to replace them
function [params,params_rep] = sort_params(params,params_rep)
    lenz = cellfun(@length,params,'UniformOutput',true);
    [v,id] = sort(lenz,'descend');
    params = params(id);
    params_rep = params_rep(id);    
endfunction

% replace command line of LIB model by NET nodes and parameters
function [cmd,item, params,params_rep] = spice_expand_command(cmd, sck_id, subckt, nodes, nodes_rep, params, params_rep)

    % no special item to return yet
    item = [];
    
    % unique subcircuit tag 
    sck_id = sprintf('%s%02d',subckt,sck_id);
    
    % check if is .param <definitions>
    [a,b,c,d,e] = regexp(cmd,'\s*.param\s+([^\n\$]+)');
    
    if ~isempty(a)
        % --- .param <definition(s)>
        
        cmd = '.param ';
        
        % globalize local parameters so it can be pasted to global NET 
        cpar = e{1}{1};
        while true
            [par,cpar] = strtok(cpar, " \t");
            if isempty(par)
                break;
            endif
            [a,b,c,d,e] = regexp(par,'\s*([^=]+)=([^\n\r]+)');
            
            % local name of parameter
            params{end+1} = e{1}{1};
            % globalized name of local parameter
            param_glob = [e{1}{1} '_' sck_id];
            params_rep{end+1}  = ['{' param_glob '}'];                     
            
            % replace local .SUBCKT params by globals
            rep_keys = {}; 
            rep_rep = {};
            value = e{1}{2};                        
            for p = 1:numel(params) % first pass - replace to temp keys 
                rep = params_rep{p};
                [a,b,c,d,e] = regexp(rep,'\{([^}]+)\}');
                if ~isempty(a)
                    rep = e{1}{1};
                endif
                rep_keys{p} = ['spice_rep_key_' int2str(rand*1e8)];
                rep_reps{p} = rep;
                value = strrep(value,params{p},rep_keys{p});
            endfor
            for p = 1:numel(params) % second pass - final replace
                value = strrep(value,rep_keys{p},rep_reps{p});
            endfor 
            
            % build new .param command with globalized paramters 
            cmd = [cmd param_glob '=' value ' '];
            
            % sort parameters
            [params,params_rep] = sort_params(params,params_rep);
                        
        endwhile        
        cmd = [cmd sprintf("\n")];
        
        return
                
    endif
    
    % try parse command
    [a,b,c,d,e] = regexp(cmd,'\s*([A-Z])([^\s]+)\s+([^\n]+)');
    
    if isempty(a)
        % no command, but it may be something else
        cmd = '';
    else
        % --- some command detected
        
        % command code
        ctype = e{1}{1};
        
        % component index
        cid = e{1}{2};
        
        % component parameters
        cpar = e{1}{3};
                
        % identify command type so we know node counts
        switch ctype
            case {'R', 'L', 'C', 'K'}
                cN = 2;
                cP = 1;
            case 'E'
                cN = 4;
                cP = 1;
            otherwise
                error(sprintf('Expanding Spice libs: command ''%s'' in SUBCKT ''%s'' not supported yet.',ctype,subckt));
        endswitch
        
        % element name/code
        element_name = [ctype cid sck_id];
        
        % build command string 
        cmd = [element_name ' '];
               
        % parse and replace nodes and parameters
        is_node = 1;
        node = cN;
        glob_nodes = {};
        while true
            [par,cpar] = strtok(cpar, " \t");
            if isempty(par)
                break;
            endif
            
            if is_node == 1
                % parsing nodes
                
                nid = find(strcmp(nodes,par));
                if isempty(nid)
                    % node is local - just make unique name
                    node_name = [par sck_id];
                else
                    % node is external - replace by external node name
                    node_name = nodes_rep{nid};
                endif
                
                % store globalized node name
                glob_nodes{end+1} = node_name;
                
                % add new node to command
                cmd = [cmd node_name ' '];
                
                cN--;
                if ~cN
                    is_node = 0; % nodes done, goto parameters
                endif
            elseif is_node == 0
                % parsing parameters
                
                [a,b,c,d,e] = regexp(par,'\{(.+)\}');
                if isempty(a)
                    % parameter is local - let it as is
                    par_value = str_get_line(par);                   
                else
                    % parameter is external - replace by external
                    pid = find(strcmp(params,e{1}{1}));
                    if isempty(pid)
                        error(sprintf('Expanding Spice libs: command ''%s'' in SUBCKT ''%s'' contains reference to unknown parameter ''%s''.',ctype,subckt,par));
                    endif
                    par_value = params_rep{pid};
                endif

                % add new node to command
                cmd = [cmd par_value ' '];
                
                cP--;
                if ~cP
                    is_node = -1; % parameters done, goto comment
                endif
            endif
            
            % parsing comment (if exist)
            if is_node < 0
                [a,b,c,d,e] = regexp(cpar,'\s*\$\s+<([^>]+)>');
                if ~isempty(a)
                    % found special tag <tag> in comment - this marks injection point for parasitic coupling
                    item.tag = e{1}{1};
                    
                    % related node
                    [a,b,c,d,e] = regexp(item.tag,'([^:]+):(.+)');
                    if ~isempty(a)
                        % explicitly defined <C:node_id> where 'node_id' is one-based index 
                        item.tag = e{1}{1}; 
                        item.node = glob_nodes{str2num(e{1}{2})};
                    else
                        % implicitly defined (first node)
                        item.node = glob_nodes{1};
                    endif                     
                    
                    % item type (node or inductor)
                    item.is_node = strcmpi(item.tag,'C');
                    
                    % command code (like inductor Lxxx or whatever)
                    item.id = element_name;
                    
                    % element value
                    [a,b,c,d,e] = regexp(par_value,'\{(.+)\}');
                    if ~isempty(a)
                        par_value = e{1}{1}; % get rid of {}
                    endif                     
                    item.value = par_value;
                    
                endif
                break;
            endif                                
            
        endwhile
        
        % append end of line
        cmd = sprintf('%s\n',cmd);       
    
    endif    

endfunction